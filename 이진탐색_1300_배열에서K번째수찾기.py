"""
이 문제는 이분탐색을 사용해야 한다.
2초의 시간이기며 N^2보다 작아야 한다고 하였기 때문.

이분탐색을 어떻게 적용하느냐.
<< 아이디어 >>
1. 다음 아래와 같은 A배열을 생각해보자.
A[] =
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25

2. A배열의 인덱스들이 B 배열내에 오름차순으로 정렬이 된다.

3. 이때 우리는 B배열에서 K번째 수를 찾아야 한다.

4. 그렇다면 K번째의 수 보다 작은 수들은 몇개가 있을까?를 알아야 한다.

5. 우선, B 배열은 다음과 같다.
B[] = [1 2 2 3 3 4 4 4 5 5 6 6 8 8 9 10 10 12 12 15 15 16 20 20 25]

6. 여기서 K = 22이라고 할 떄 B[22] = 16이다.

7. 이때 B[22]보다 작은 수들은 몇개가 있을까?

8. A배열을 보면 각 인덱스들은 i*j의 꼴로 이루어져 있다. 2중 for문의 형태이며 각 행, 즉 i는 고정되며 j는 변한다.

9. 따라서 2열을 예로 들면 인덱스를 i(2)로 나눌경우 1,2,3,4,5가 된다. 즉, 이 열에서 가장 큰 수는 N(5)라는 뜻이다. 이는 모든 열에 적용된다.

10. 이제 특정 수 (16)을 i로 나누어 보자, 16//2 = 8이다. 즉, 5보다 큰 값을 가지며 2열에서는 모든 숫자가 8보다 작다는 뜻이다. 따라서 5가 값이 된다.( min (8,5) )

11. 4열로 예를 들어보자. 16 // 4 = 4이다. 5보다 작은 값을 가지며, 이때 이 값은 4번째라는 의미이므로 min(4,5) = 4가 된다.

12. 이렇게 우리는 각 열마다 몇개의 인덱스가 특정 수보다 작은지 알아볼 수 있다.

<< 이분 탐색 진행 >>
1. 그럼 이제 k번째 수를 구한다. k번째 수는 앞에 k-1개가 있는지 확인하면 된다.

2. 시작점은 1이 되며 끝점은 N^2이 된다. 중간점은 (시작점 + 끝점) // 2가 된다.

3. 이분탐색을 진행하며 이때 조건은 다음과 같다.
    1) 중간점을 기준으로 해당 값보다 작은 값이 몇개인지 확인한다.
    2) 만약 작은 값이 k개보다 작다면 시작점을 중간점 + 1로 옮긴다.
    3) 만약 작은 값이 k개보다 크거나 같다면 끝점을 중간점 - 1로 옮긴다.
    4) 이때 작은 값이 k개보다 크거나 같다면 중간점을 기록해둔다.
    

4. 필요한 변수 : 시작점, 끝점, 중간점, 

틀린 처음 코드
import sys
input = sys.stdin.readline

n = int(input())

array = [[0 for j in range(n + 1)] for i in range(n + 1)]
for i in range(n + 1):
    for j in range(n + 1):
        array[i][j] = i * j

array_1d = [item for row in array[1:] for item in row[1:]]

array_1d.sort()
k = int(input())
print(array_1d[k])

"""

import sys

input = sys.stdin.readline

n = int(input())
k = int(input())
start, end = 1, n**2
result = 0

# 이분 탐색을 진행한다.
while start <= end:
    mid = (start + end) // 2
    cnt = 0
    # mid보다 작은 수들의 개수를 센다.
    for i in range(1, n + 1):  # 행 만큼 반복
        cnt += min(mid // i, n)

    if cnt < k:
        start = mid + 1
    elif cnt >= k:
        end = mid - 1
        result = mid


print(result)
